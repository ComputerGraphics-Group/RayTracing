<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Process and Results</title>
  <meta name="description" content="Process and Results">
  <meta name="author" content="PSK">

  <link rel="stylesheet" href="styles.css">

</head>

<body>
  <div class="segment">
      <div class="title">
        Introduction
      </div>
      <div class="content">
        So far, we have gotten the initial grasp of how OpenGL works, so we can confidently experiment with our own original code. By the end of the previous assignment, we had already learnt quite a bit
        about 3D manipulation through our browsing and exploration of OpenGL so we could immediately go ahead with projection without fear. In fact, by the time we actually checked the assignment details, it turns out that
        we had already completed almost all the requirements mentioned! Now we can go through each step in the process.
      </div>
  </div>
  <div class='segment'>
    <div class='title'>
      Moving to 3D
    </div>
    <div class="content">
      We already tried out making primitive triangles in a three-dimensional setting, so we decided to start out with a cube due to its simplicity. We simply needed to set the appropriate vertices and enable z-buffer depth testing
      for a correct model to be displayed.
      <div class="image">
        <img src="cubeFirst.png">
        <div class="label">
          Primitive cube using triangles
        </div>
      </div>
      This is a 3D object but it doesn't look that way yet. We can apply tranformation matrices, specifically rotation matrices, to make it turn and expose it's "3D-ness".
      <div class="image">
        <img src="cube.png">
        <div class="label">
          Cube rotated
        </div>
      </div>
      By this point we were already getting tired of manually changing the rotation matrices on every compile. To remedy this we decided to take the assistance of a useful tool called ImGUI
      that would allow us to adjust values in realtime in a GUI inspector. This was a great move on our part and it remained useful through the rest of the project.
      <div class="image">
        <img src="cubeRotating.gif">
        <div class="label">
          Cube with live rotation about the 3 axes
        </div>
      </div>
      The next primitive we rendered was a sphere. One approach to rendering this is to:<br>1) Render an Octagon
      <div class="image">
        <img src="octagonRotating.gif">
        <div class="label">
          Octagon
        </div>
      </div>
      <br>2) Tessellate the surfaces
      <div class="image">
        <img src="octagonTessellatedRotating.gif">
        <div class="label">
          Octagon tessellated
        </div>
      </div>
      <br>3) Normalize all the vertices to be a fixed distance away from the centre
      <div class="image">
        <img src="octagonTessellatedNormalizedRotating.gif">
        <div class="label">
          Octagon tessellated and normalized a.k.a Octasphere
        </div>
      </div>
      Another method of generating a sphere is to tessellate an icosahedron instead of an octagon, known as an icosphere. This is the result:
      <div class="image">
        <img src="icoSphere.gif">
        <div class="label">
          Icosphere
        </div>
      </div>
      The next primitive we rendered was a cone. For that, we needed to do 3 things again: <br>1) Render a square pyramid
      <div class="image">
        <img src="squarePyramid.gif">
        <div class="label">
          Square pyramid
        </div>
      </div>
      <br>2) Split the faces vertically
      <div class="image">
        <img src="squarePyramidSplit.gif">
        <div class="label">
          Square pyramid with vertical splits
        </div>
      </div>
      <br>3) Normalize the base vertices so that they are a fixed distance from the the centre of the base
      <div class="image">
        <img src="squarePyramidSplitNormalized.gif">
        <div class="label">
          Cone
        </div>
      </div>
      Now that that was done, we decided to start off with some good camera actions to interact with the scene properly. 
    </div>
  </div>
  <div class='segment'>
    <div class='title'>
      Camera movement and the projection/model/view system
    </div>
    <div class='content'>
      The mechanism of movement is simple: instead of moving a physical camera or viewport around, you simply move the entire world around your camera. That involves changing the world angles and directions based 
      on your input. The way we achieved this is to make a Camera class which stores every single datapoint we need for a Camera to function such as direction vectors and the 3 main angles - Yaw, Pitch and Roll. Then
      we make a driver function that continuously updates these vectors every frame of input.
      <div class='one-line-code'>
        <div class='image'>
          <img src="cam1.png">
        </div>
      </div>
      Now we simply make GL callbacks to change each appropriate variable as we intend. For back and forth movement, we use the W and S keys (note that we do not use the A and D keys for left
      and right movement: the reason for this is apparent later). We also add a scroll feature for zooming in and out.
      <div class='one-line-code'>
        <div class='image'>
          <img src="cam2.png">
        </div>
      </div>
      Then we make a GL mouse callback to check for the middle click button and mouse movement when it is active for panning the mouse, which moves the camera across the plane parallel to the
      viewport (this is why A and D are not implemented for left and right movement). If middle click is not active, right click rotates the camera instead.
      <div class='one-line-code'>
        <div class='image'>
          <img src="cam3.png">
        </div>
      </div>
      Finally we make a special function for A and D to roll the camera. This function is normally a questionable one as it is barely used for anything, which is why most 3D modelling tools never
      implement it. However it's sometimes a useful tool to use.
      <div class='one-line-code'>
        <div class='image'>
          <img src="cam4.png">
        </div>
      </div>
      Now, we can finally see these functions in action. This is what moving back and forth looks like...
      <div class="image">
        <img src="cam5.gif">
        <label>Back and forth</label>
      </div>
      This is panning and rotating the camera...
      <div class="image">
        <img src="cam6.gif">
        <label>Panning and rotation</label>
      </div>
      And finally, this is the roll.
      <div class="image">
        <img src="cam7.gif">
        <label>Rolling</label>
      </div>
    </div>
  </div>
  <div class='segment'>
    <div class='title'>
      Expanding further
    </div>
    <div class='content'>
      The next step is to get a sense of orientation and position, so we added a grid system. Subsequently, we also added a model loading class that reads .obj files generated form
      3D modelling softwares like Blender and renders them. This is the final result of our Assignment:
      <div class="image">
        <img src="final.gif">
        <label>Final</label>
      </div>
    </div>
</body>
</html>